<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Pasillo 3D - Crosshair y casco elevado</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }

    /* Botón de compra, oculto por defecto */
    #buyButton {
      display: none; 
      position: absolute;
      top: 10px; 
      left: 10px; 
      padding: 10px 16px;
      background-color: #007bff;
      color: #fff; 
      border: none;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
      z-index: 999;
    }
    #buyButton:hover {
      background-color: #0056b3;
    }

    /* Overlay para indicar "Haz clic para iniciar" */
    #blocker {
      position: absolute;
      top:0; left:0; 
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 1000;
    }
    #instructions {
      position: absolute;
      top: 50%; 
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 24px;
      user-select: none;
    }

    /* Imagen del crosshair en el centro de la pantalla */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      pointer-events: none; /* no bloquea clics */
    }
  </style>
</head>
<body>

<!-- Bloque para "pointer lock" (instrucciones) -->
<div id="blocker">
  <div id="instructions">
    <span>Clic para iniciar</span>
    <br /><br />
    (W, A, S, D para moverte / Mouse para girar)
  </div>
</div>

<!-- Botón de compra -->
<button id="buyButton">Comprar</button>

<!-- Imagen del crosshair en el centro -->
<div id="crosshair">
  <!-- Ajusta el src a tu propia imagen de retícula -->
  <img src="crosshair.png" width="32" height="32" alt="Crosshair">
</div>

<!-- 1) Import map para que 'three' sea resuelto en loaders/controls -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/controls/PointerLockControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js';

  // Variables principales
  let camera, scene, renderer;
  let controls;
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

  // Medidas del pasillo
  const corridorWidth = 4;
  const corridorHeight = 3;
  const corridorLength = 20;

  let helmetModel = null; 
  let buyButton;          
  let raycaster;          

  init();
  animate();

  function init() {
    // Escena
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc);

    // Cámara
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, 0); // Altura ~1.5m

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Luces
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Crear pasillo
    createCorridor();

    // Cargar DamagedHelmet, elevándolo ~1m
    const loader = new GLTFLoader();
    loader.load(
      'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf',
      (gltf) => {
        helmetModel = gltf.scene;
        helmetModel.scale.set(1,1,1);
        helmetModel.position.set(0, 1, -10); // Y=1 para que no se hunda
        scene.add(helmetModel);
      },
      undefined,
      (error) => console.error(error)
    );

    // PointerLockControls
    controls = new PointerLockControls(camera, renderer.domElement);
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');

    controls.addEventListener('lock', () => {
      instructions.style.display = 'none';
      blocker.style.display = 'none';
    });
    controls.addEventListener('unlock', () => {
      blocker.style.display = 'block';
      instructions.style.display = '';
    });
    blocker.addEventListener('click', () => {
      controls.lock();
    });
    scene.add(controls.getObject());

    // Teclado
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // Raycaster (para clic en el casco)
    raycaster = new THREE.Raycaster();
    document.addEventListener('click', onMouseClick);

    // Botón comprar
    buyButton = document.getElementById('buyButton');
    buyButton.addEventListener('click', () => {
      alert('¡Producto agregado al carrito (demostración)!');
    });

    window.addEventListener('resize', onWindowResize);
  }

  function createCorridor() {
    // Suelo
    const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.z = -corridorLength / 2; 
    scene.add(floor);

    // Techo
    const ceilingGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
    const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = corridorHeight;
    ceiling.position.z = -corridorLength / 2;
    scene.add(ceiling);

    // Pared izquierda
    const wallGeom = new THREE.PlaneGeometry(corridorHeight, corridorLength);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
    const leftWall = new THREE.Mesh(wallGeom, wallMat);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.rotation.z = -Math.PI / 2;
    leftWall.position.x = -corridorWidth / 2;
    leftWall.position.z = -corridorLength / 2;
    leftWall.position.y = corridorHeight / 2;
    scene.add(leftWall);

    // Pared derecha
    const rightWall = new THREE.Mesh(wallGeom, wallMat);
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.rotation.z = -Math.PI / 2;
    rightWall.position.x = corridorWidth / 2;
    rightWall.position.z = -corridorLength / 2;
    rightWall.position.y = corridorHeight / 2;
    scene.add(rightWall);
  }

  function onKeyDown(event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW': moveForward = true; break;
      case 'ArrowLeft':
      case 'KeyA': moveLeft = true; break;
      case 'ArrowDown':
      case 'KeyS': moveBackward = true; break;
      case 'ArrowRight':
      case 'KeyD': moveRight = true; break;
    }
  }
  function onKeyUp(event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW': moveForward = false; break;
      case 'ArrowLeft':
      case 'KeyA': moveLeft = false; break;
      case 'ArrowDown':
      case 'KeyS': moveBackward = false; break;
      case 'ArrowRight':
      case 'KeyD': moveRight = false; break;
    }
  }

  function onMouseClick(event) {
    if (!controls.isLocked) return; // Solo si estás en modo FPS
    // Rayo desde el centro de la pantalla
    const mouse = new THREE.Vector2(0, 0);
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0 && helmetModel) {
      for (let i = 0; i < intersects.length; i++) {
        const obj = intersects[i].object;
        if (isDescendantOf(obj, helmetModel)) {
          console.log('¡Casco clickeado!');
          buyButton.style.display = 'block';
          break;
        }
      }
    }
  }

  function isDescendantOf(child, parent) {
    let current = child;
    while (current) {
      if (current === parent) return true;
      current = current.parent;
    }
    return false;
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    if (controls.isLocked) {
      let step = 0.1;
      let moveX = 0;
      let moveZ = 0;

      if (moveForward)  moveZ -= step;
      if (moveBackward) moveZ += step;
      if (moveLeft)     moveX -= step;
      if (moveRight)    moveX += step;

      if (moveX !== 0) controls.moveRight(moveX);
      if (moveZ !== 0) controls.moveForward(moveZ);

      clampCameraToCorridor();
    }

    renderer.render(scene, camera);
  }

  function clampCameraToCorridor() {
    const halfW = corridorWidth / 2 - 0.2;
    if (camera.position.x < -halfW) camera.position.x = -halfW;
    if (camera.position.x >  halfW) camera.position.x =  halfW;

    if (camera.position.z > 0) camera.position.z = 0;
    const minZ = -corridorLength;
    if (camera.position.z < minZ) camera.position.z = minZ;
  }
</script>
</body>
</html>
